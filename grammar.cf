entrypoints Program;


comment "--";


-- redefinition of certain tokens due to the disparity between
-- Haskell's identifier rules and Modula's identifier convention
token Iden (letter (letter | digit | '_')*);


-- entry point
Prog. Program ::= [GlobDecl];


-- global declarations are coerced under GlobDecl; this includes
-- functions, global variables, classes, include statements, etc
GMemDecl. GlobDecl ::= ClassMemDecl;
GClassDecl. GlobDecl ::= ClassDecl;
GImport. GlobDecl ::= ImportDecl;
separator GlobDecl "";


-- import statement declaration
IImport. ImportDecl ::= "import" [Pack] ";";
PackName. Pack ::= Iden;

separator nonempty Pack ".";


-- in-class declarations are similar to the global declaration
-- set apart from the inclusion of class/interface declarations
CVarDecl. ClassMemDecl ::= GVarDef ";";

separator ClassMemDecl "";


-- class declaration
CClass. ClassDecl ::= [PropDecl] "class" Iden Inhrt "{" [ClassMemDecl] "}";
CInter. ClassDecl ::= [PropDecl] "interface" Iden Inhrt "{" [ClassMemDecl] "}";

INoInherit. Inhrt ::= ;
IInherit. Inhrt ::= ":" [CType];


-- property construct (occurs before a global definition) that
-- can be stacked indefinitely before a global declaration
-- e.g. `[private static]`
PName. Prop ::= Iden;
PProp. PropDecl ::= "[" [Prop] "]";

separator nonempty Prop " ";
separator PropDecl "";


-- simple variable definitions (the generic kind without global
-- properties)
VSig. VarSig ::= Iden ":" Type;

VNoAsn. VarDef ::= VarSig;
VAsn. VarDef ::= VarSig "=" Exp;

separator nonempty VarDef ",";


-- global variable definitions (with optional properties section)
MPropVar. GVarDef ::= [PropDecl] [VarDef];


-- `certainly` type structure (no succeeding `?`)
CSimp. CType ::= Iden;
CGen. CType ::= Iden "<" [Type] ">";
CList. CType ::= "[" Type "]";
CTup. CType ::= "(" [Type] ")";

separator nonempty CType ",";


-- maybe type structure (coerces `null` into the type) (does not
-- work on primitives obviously, but such validation is postponed
-- until static analysis)
TMaybe. Type ::= CType "?";
TPure. Type ::= CType;

separator nonempty Type ",";


-- literals
LInt. Lit ::= Integer;
LStr. Lit ::= String;
LChr. Lit ::= Char;
LFlo. Lit ::= Double;


-- operators
Asn. Op ::= "=";
AddAsn. Op ::= "+=";
SubAsn. Op ::= "-=";
MulAsn. Op ::= "*=";
DivAsn. Op ::= "/=";
ModAsn. Op ::= "%=";
AndAsn. Op ::= "&=";
XorAsn. Op ::= "^=";
OrAsn. Op ::= "|=";
ShlAsn. Op ::= "<<=";
ShrAsn. Op ::= ">>=";

LogOr. Op1 ::= "||";
LogAnd. Op2 ::= "&&";
BitOr. Op3 ::= "|";
BitXor. Op4 ::= "^";
BitAnd. Op5 ::= "&";

NotEq. Op6 ::= "!=";
Eq. Op6 ::= "==";
Lt. Op7 ::= "<";
Gt. Op7 ::= ">";
Leq. Op7 ::= "<=";
Geq. Op7 ::= ">=";

Shl. Op8 ::= "<<";
Shr. Op8 ::= ">>";
Add. Op9 ::= "+";
Sub. Op9 ::= "-";
Mul. Op10 ::= "*";
Div. Op10 ::= "/";
Mod. Op10 ::= "%";
Pow. Op11 ::= "**";
Ref. Op13 ::= ".";


-- expressions
internal EOp. Exp ::= Exp Op Exp;
define opf a o b = EOp a o b;

opf. Exp ::= Exp Op Exp1;
opf. Exp1 ::= Exp1 Op1 Exp2;
opf. Exp2 ::= Exp2 Op2 Exp3;
opf. Exp3 ::= Exp3 Op3 Exp4;
opf. Exp4 ::= Exp4 Op4 Exp5;
opf. Exp5 ::= Exp5 Op5 Exp6;
opf. Exp6 ::= Exp6 Op6 Exp7;
opf. Exp7 ::= Exp7 Op7 Exp8;
opf. Exp8 ::= Exp8 Op8 Exp9;
opf. Exp9 ::= Exp9 Op9 Exp10;
opf. Exp10 ::= Exp10 Op10 Exp11;
opf. Exp11 ::= Exp12 Op11 Exp11;
opf. Exp13 ::= Exp13 Op13 Exp14;

PreInc. Exp12 ::= "++" Exp13;
PreDec. Exp12 ::= "--" Exp13;
Pos. Exp12 ::= "+" Exp13;
Neg. Exp12 ::= "-" Exp13;
LogNot. Exp12 ::= "!" Exp13;
BitNot. Exp12 ::= "~" Exp13;

SufInc. Exp13 ::= Exp14 "++";
SufDec. Exp13 ::= Exp14 "--";
ArrIdx. Exp13 ::= Exp14 "[" Exp "]";
FuncCall. Exp13 ::= Exp14 "(" [Exp] ")";

ELit. Exp14 ::= Lit;
EIde. Exp14 ::= Iden;

coercions Exp 14;
separator Exp ",";

entrypoints Program;


comment "--";


-- redefinition of certain tokens due to the disparity between
-- Haskell's identifier rules and Modula's identifier convention
token Iden (letter (letter | digit | '_')*);

separator Iden ",";


-- entry point
Prog. Program ::= [GlobDecl];


-- global declarations are coerced under GlobDecl; this includes
-- functions, global variables, classes, include statements, etc
GMemDecl. GlobDecl ::= ClassMemDecl;
GClassDecl. GlobDecl ::= ClassDecl;
GImport. GlobDecl ::= ImportDecl;
separator GlobDecl "";


-- import statement declaration
IImport. ImportDecl ::= [PropDecl] "import" [Pack] ";";
PackName. Pack ::= Iden;

separator nonempty Pack ".";


-- in-class declarations are similar to the global declaration
-- set apart from the inclusion of class/interface declarations
CVarDecl. ClassMemDecl ::= GVarDef ";";
CFuncDecl. ClassMemDecl ::= FuncDecl;

separator ClassMemDecl "";


-- type parameter declaration
TSimp. TypeArg ::= Iden;
TCov. TypeArg ::= Iden ":" Type;
TContra. TypeArg ::= "contra" Iden ":" Type;

separator nonempty TypeArg ",";

TNil. TArgsDecl ::= ;
TDecl. TArgsDecl ::= "<" [TypeArg] ">";


-- function declaration
FFunc. FuncDecl ::= [PropDecl] Iden TArgsDecl "(" [ParaSig] ")" ":" Type FuncBody;

FAbsBody. FuncBody ::= ;
FConBody. FuncBody ::= StmtBlock;

PSig. ParaSig ::= Iden ":" Type;
separator ParaSig ",";


-- class declaration
CClass. ClassDecl ::= [PropDecl] "class" Iden TArgsDecl Inhrt "{" [ClassMemDecl] "}";
CInter. ClassDecl ::= [PropDecl] "interface" TArgsDecl Iden Inhrt "{" [ClassMemDecl] "}";

INoInherit. Inhrt ::= ;
IInherit. Inhrt ::= ":" [CType];


-- property construct (occurs before a global definition) that
-- can be stacked indefinitely before a global declaration
-- e.g. `[private static]`
PName. Prop ::= Iden;
PProp. PropDecl ::= "[" [Prop] "]";

separator nonempty Prop " ";
separator PropDecl "";


-- simple variable definitions (the generic kind without global
-- properties)
VSig. VarSig ::= [Iden] ":" Type;

VNoAsn. VarDef ::= VarSig;
VAsn. VarDef ::= VarSig "=" [Exp];


-- global variable definitions (with optional properties section)
MPropVar. GVarDef ::= [PropDecl] VarDef;


-- `certainly` type structure (no succeeding `?`)
CSimp. CType ::= Iden;
CGen. CType ::= Iden "<" [Type] ">";
CList. CType ::= "[" Type "]";
CTup. CType ::= "(" [Type] ")";

separator nonempty CType ",";


-- maybe type structure (coerces `null` into the type) (does not
-- work on primitives obviously, but such validation is postponed
-- until static analysis)
TMaybe. Type ::= CType "?";
TPure. Type ::= CType;

separator nonempty Type ",";


-- literals
LInt. Lit ::= Integer;
LStr. Lit ::= String;
LChr. Lit ::= Char;
LFlo. Lit ::= Double;


-- operators
Asn. Op ::= "=";
AddAsn. Op ::= "+=";
SubAsn. Op ::= "-=";
MulAsn. Op ::= "*=";
DivAsn. Op ::= "/=";
ModAsn. Op ::= "%=";
AndAsn. Op ::= "&=";
XorAsn. Op ::= "^=";
OrAsn. Op ::= "|=";
ShlAsn. Op ::= "<<=";
ShrAsn. Op ::= ">>=";

LogOr. Op1 ::= "||";
LogAnd. Op2 ::= "&&";
BitOr. Op3 ::= "|";
BitXor. Op4 ::= "^";
BitAnd. Op5 ::= "&";

NotEq. Op6 ::= "!=";
Eq. Op6 ::= "==";
Lt. Op7 ::= "<";
Gt. Op7 ::= ">";
Leq. Op7 ::= "<=";
Geq. Op7 ::= ">=";

Shl. Op8 ::= "<<";
Shr. Op8 ::= ">>";
Add. Op9 ::= "+";
Sub. Op9 ::= "-";
Mul. Op10 ::= "*";
Div. Op10 ::= "/";
Mod. Op10 ::= "%";
Pow. Op11 ::= "**";
Ref. Op13 ::= ".";


-- statements
SExp. Stmt ::= Exp ";";
SDecl. Stmt ::= VarDef ";";
SRetNil. Stmt ::= "return" ";";
SRet. Stmt ::= "return" Exp ";";
SBreak. Stmt ::= "break" ";";
SCont. Stmt ::= "continue" ";";

SIf. Stmt ::= AliasIf;
SFor. Stmt ::= "for" Iden "in" Exp StmtBlock;
SWhile. Stmt ::= "while" Exp StmtBlock;

EEmpty. Else ::= ;
EElse. Else ::= "else" StmtBlock;
EElif. Else ::= "else" AliasIf;

AIf. AliasIf ::= "if" Exp StmtBlock Else;

separator Stmt "";
SStmt. StmtBlock ::= "{" [Stmt] "}";


-- expressions
internal EOp. Exp ::= Exp Op Exp;
define opf a o b = EOp a o b;

opf. Exp1 ::= Exp1 Op Exp2;
opf. Exp2 ::= Exp2 Op1 Exp3;
opf. Exp3 ::= Exp3 Op2 Exp4;
opf. Exp4 ::= Exp4 Op3 Exp5;
opf. Exp5 ::= Exp5 Op4 Exp6;
opf. Exp6 ::= Exp6 Op5 Exp7;
opf. Exp7 ::= Exp7 Op6 Exp8;
opf. Exp8 ::= Exp8 Op7 Exp9;
opf. Exp9 ::= Exp9 Op8 Exp10;
opf. Exp10 ::= Exp10 Op9 Exp11;
opf. Exp11 ::= Exp11 Op10 Exp12;
opf. Exp12 ::= Exp13 Op11 Exp12;
opf. Exp13 ::= Exp14 Op13 Exp15;

PreInc. Exp13 ::= "++" Exp13;
PreDec. Exp13 ::= "--" Exp13;
Pos. Exp13 ::= "+" Exp13;
Neg. Exp13 ::= "-" Exp13;
LogNot. Exp13 ::= "!" Exp13;
BitNot. Exp13 ::= "~" Exp13;

SufInc. Exp14 ::= Exp14 "++";
SufDec. Exp14 ::= Exp14 "--";
ArrIdx. Exp14 ::= Exp14 "[" Exp "]";
FuncCall. Exp14 ::= Exp14 "(" [Exp] ")";

ELit. Exp15 ::= Lit;
EIde. Exp15 ::= Iden;
ENil. Exp15 ::= "null";

coercions Exp 15;
separator Exp ",";

ESing. Exp ::= Iden "->" LamBody;
EMore. Exp ::= "\\" "(" [Iden] ")" "->" LamBody;

ETupOne. Exp ::= "(" Exp "," ")";
ETupTwo. Exp ::= "(" Exp "," Exp OptionExp ")";

ONil. OptionExp ::= ;
OExp. OptionExp ::= "," [Exp];

EList. Exp ::= "[" [Exp] "]";

LExp. LamBody ::= Exp;
--LStm. LamBody ::= StmtBlock;

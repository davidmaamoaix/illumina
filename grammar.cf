entrypoints Program;


comment "--";


-- redefinition of certain tokens due to the disparity between
-- Haskell's identifier rules and Modula's identifier convention
token Iden (letter (letter | digit | '_')*);


-- entry point
Prog. Program ::= [GlobDecl];


-- global declarations are coerced under GlobDecl; this includes
-- functions, global variables, classes, include statements, etc
GMemDecl. GlobDecl ::= ClassMemDecl;
GClassDecl. GlobDecl ::= ClassDecl;
GImport. GlobDecl ::= ImportDecl;
separator GlobDecl "";


-- import statement declaration
IImport. ImportDecl ::= "import" [Pack] ";";
PackName. Pack ::= Iden;
separator nonempty Pack ".";


-- in-class declarations are similar to the global declaration
-- set apart from the inclusion of class/interface declarations
CVarDecl. ClassMemDecl ::= GVarDef ";";
separator ClassMemDecl "";


-- class declaration
CClass. ClassDecl ::= [PropDecl] "class" Iden Inhrt "{" [ClassMemDecl] "}";
CInter. ClassDecl ::= [PropDecl] "interface" Iden Inhrt "{" [ClassMemDecl] "}";

INoInherit. Inhrt ::= ;
IInherit. Inhrt ::= ":" [CType];


-- property construct (occurs before a global definition) that
-- can be stacked indefinitely before a global declaration
-- e.g. `[private static]`
PName. Prop ::= Iden;
separator nonempty Prop " ";
PProp. PropDecl ::= "[" [Prop] "]";
separator PropDecl "";


-- simple variable definitions (the generic kind without global
-- properties)
VSig. VarSig ::= Iden ":" Type;

VNoAsn. VarDef ::= VarSig;
VAsn. VarDef ::= VarSig "=" Exp;
separator nonempty VarDef ",";


-- global variable definitions (with optional properties section)
MPropVar. GVarDef ::= [PropDecl] [VarDef];


-- `certainly` type structure (no succeeding `?`)
CSimp. CType ::= Iden;
CGen. CType ::= Iden "<" [Type] ">";
CList. CType ::= "[" Type "]";
CTup. CType ::= "(" [Type] ")";
separator nonempty CType ",";


-- maybe type structure (coerces `null` into the type) (does not
-- work on primitives obviously, but such validation is postponed
-- until static analysis)
TMaybe. Type ::= CType "?";
TPure. Type ::= CType;
separator nonempty Type ",";


-- expressions
EInt. Exp ::= Integer;
EStr. Exp ::= String;

entrypoints Program;


comment "--";


-- redefinition of certain tokens due to the disparity between
-- Haskell's identifier rules and Modula's identifier convention
token Iden (letter (letter | digit | '_')*);


-- entry point
Prog. Program ::= [GlobDecl];


-- global declarations are coerced under GlobDecl; this includes
-- functions, global variables, classes, include statements, etc
GMemDecl. GlobDecl ::= ClassMemDecl;
GClassDecl. GlobDecl ::= ClassDecl;
GImport. GlobDecl ::= ImportDecl;
separator GlobDecl "";


-- import statement declaration
IImport. ImportDecl ::= "import" [Pack] ";";
PackName. Pack ::= Iden;

separator nonempty Pack ".";


-- in-class declarations are similar to the global declaration
-- set apart from the inclusion of class/interface declarations
CVarDecl. ClassMemDecl ::= GVarDef ";";

separator ClassMemDecl "";


-- class declaration
CClass. ClassDecl ::= [PropDecl] "class" Iden Inhrt "{" [ClassMemDecl] "}";
CInter. ClassDecl ::= [PropDecl] "interface" Iden Inhrt "{" [ClassMemDecl] "}";

INoInherit. Inhrt ::= ;
IInherit. Inhrt ::= ":" [CType];


-- property construct (occurs before a global definition) that
-- can be stacked indefinitely before a global declaration
-- e.g. `[private static]`
PName. Prop ::= Iden;
PProp. PropDecl ::= "[" [Prop] "]";

separator nonempty Prop " ";
separator PropDecl "";


-- simple variable definitions (the generic kind without global
-- properties)
VSig. VarSig ::= Iden ":" Type;

VNoAsn. VarDef ::= VarSig;
VAsn. VarDef ::= VarSig "=" Exp;

separator nonempty VarDef ",";


-- global variable definitions (with optional properties section)
MPropVar. GVarDef ::= [PropDecl] [VarDef];


-- `certainly` type structure (no succeeding `?`)
CSimp. CType ::= Iden;
CGen. CType ::= Iden "<" [Type] ">";
CList. CType ::= "[" Type "]";
CTup. CType ::= "(" [Type] ")";

separator nonempty CType ",";


-- maybe type structure (coerces `null` into the type) (does not
-- work on primitives obviously, but such validation is postponed
-- until static analysis)
TMaybe. Type ::= CType "?";
TPure. Type ::= CType;

separator nonempty Type ",";


-- literals
LInt. Lit ::= Integer;
LStr. Lit ::= String;
LChr. Lit ::= Char;
LFlo. Lit ::= Double;

-- operators
Asn. Op ::= "=";
AddAsn. Op ::= "+=";
SubAsn. Op ::= "-=";
MulAsn. Op ::= "*=";
DivAsn. Op ::= "/=";
ModAsn. Op ::= "%=";
AndAsn. Op ::= "&=";
XorAsn. Op ::= "^=";
OrAsn. Op ::= "|=";
ShlAsn. Op ::= "<<=";
ShrAsn. Op ::= ">>=";

LogOr. Op1 ::= "||";
LogAnd. Op2 ::= "&&";
BitOr. Op3 ::= "|";
BitXor. Op4 ::= "^";
BitAnd. Op5 ::= "&";

NotEq. Op6 ::= "!=";
Eq. Op6 ::= "==";
Lt. Op7 ::= "<";
Gt. Op7 ::= ">";
Leq. Op7 ::= "<=";
Geq. Op7 ::= ">=";

Shl. Op8 ::= "<<";
Shr. Op8 ::= ">>";
Add. Op9 ::= "+";
Sub. Op9 ::= "-";
Mul. Op10 ::= "*";
Div. Op10 ::= "/";
Mod. Op10 ::= "%";

_. Op ::= Op1;
_. Op ::= Op2;
_. Op ::= Op3;
_. Op ::= Op4;
_. Op ::= Op5;
_. Op ::= Op6;
_. Op ::= Op7;
_. Op ::= Op8;
_. Op ::= Op9;
_. Op ::= Op10;


-- expressions
internal EOp. Exp ::= Exp Op Exp;
define opf a o b = EOp a o b;

opf. Exp ::= Exp Op Exp1;
opf. Exp1 ::= Exp1 Op1 Exp2;
--opf. Exp2 ::= Exp2 Op2 Exp3;
--opf. Exp3 ::= Exp3 Op3 Exp4;
--opf. Exp4 ::= Exp4 Op4 Exp5;
--opf. Exp5 ::= Exp5 Op5 Exp6;
--opf. Exp6 ::= Exp6 Op6 Exp7;
--opf. Exp7 ::= Exp7 Op7 Exp8;
--opf. Exp8 ::= Exp8 Op8 Exp9;
--opf. Exp9 ::= Exp9 Op9 Exp10;
--opf. Exp10 ::= Exp10 Op10 Exp11;

Elit. Exp2 ::= Lit;

--coercions Exp 2;
--separator Exp ",";


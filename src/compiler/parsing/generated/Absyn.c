/* File generated by the BNF Converter (bnfc 2.9.3). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   ListIden    ********************/

ListIden make_ListIden(Iden p1, ListIden p2)
{
    ListIden tmp = (ListIden) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListIden!\n");
        exit(1);
    }
    tmp->iden_ = p1;
    tmp->listiden_ = p2;
    return tmp;
}

/********************   Prog    ********************/

Program make_Prog(ListGlobDecl p1)
{
    Program tmp = (Program) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Prog!\n");
        exit(1);
    }
    tmp->kind = is_Prog;
    tmp->u.prog_.listglobdecl_ = p1;
    return tmp;
}

/********************   GMemDecl    ********************/

GlobDecl make_GMemDecl(ClassMemDecl p1)
{
    GlobDecl tmp = (GlobDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating GMemDecl!\n");
        exit(1);
    }
    tmp->kind = is_GMemDecl;
    tmp->u.gmemdecl_.classmemdecl_ = p1;
    return tmp;
}

/********************   GClassDecl    ********************/

GlobDecl make_GClassDecl(ClassDecl p1)
{
    GlobDecl tmp = (GlobDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating GClassDecl!\n");
        exit(1);
    }
    tmp->kind = is_GClassDecl;
    tmp->u.gclassdecl_.classdecl_ = p1;
    return tmp;
}

/********************   GImport    ********************/

GlobDecl make_GImport(ImportDecl p1)
{
    GlobDecl tmp = (GlobDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating GImport!\n");
        exit(1);
    }
    tmp->kind = is_GImport;
    tmp->u.gimport_.importdecl_ = p1;
    return tmp;
}

/********************   ListGlobDecl    ********************/

ListGlobDecl make_ListGlobDecl(GlobDecl p1, ListGlobDecl p2)
{
    ListGlobDecl tmp = (ListGlobDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListGlobDecl!\n");
        exit(1);
    }
    tmp->globdecl_ = p1;
    tmp->listglobdecl_ = p2;
    return tmp;
}

/********************   IImport    ********************/

ImportDecl make_IImport(ListPropDecl p1, ListPack p2)
{
    ImportDecl tmp = (ImportDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating IImport!\n");
        exit(1);
    }
    tmp->kind = is_IImport;
    tmp->u.iimport_.listpropdecl_ = p1;
    tmp->u.iimport_.listpack_ = p2;
    return tmp;
}

/********************   PackName    ********************/

Pack make_PackName(Iden p1)
{
    Pack tmp = (Pack) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PackName!\n");
        exit(1);
    }
    tmp->kind = is_PackName;
    tmp->u.packname_.iden_ = p1;
    return tmp;
}

/********************   ListPack    ********************/

ListPack make_ListPack(Pack p1, ListPack p2)
{
    ListPack tmp = (ListPack) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListPack!\n");
        exit(1);
    }
    tmp->pack_ = p1;
    tmp->listpack_ = p2;
    return tmp;
}

/********************   CVarDecl    ********************/

ClassMemDecl make_CVarDecl(GVarDef p1)
{
    ClassMemDecl tmp = (ClassMemDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CVarDecl!\n");
        exit(1);
    }
    tmp->kind = is_CVarDecl;
    tmp->u.cvardecl_.gvardef_ = p1;
    return tmp;
}

/********************   CFuncDecl    ********************/

ClassMemDecl make_CFuncDecl(FuncDecl p1)
{
    ClassMemDecl tmp = (ClassMemDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CFuncDecl!\n");
        exit(1);
    }
    tmp->kind = is_CFuncDecl;
    tmp->u.cfuncdecl_.funcdecl_ = p1;
    return tmp;
}

/********************   ListClassMemDecl    ********************/

ListClassMemDecl make_ListClassMemDecl(ClassMemDecl p1, ListClassMemDecl p2)
{
    ListClassMemDecl tmp = (ListClassMemDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListClassMemDecl!\n");
        exit(1);
    }
    tmp->classmemdecl_ = p1;
    tmp->listclassmemdecl_ = p2;
    return tmp;
}

/********************   TSimp    ********************/

TypeArg make_TSimp(Iden p1)
{
    TypeArg tmp = (TypeArg) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TSimp!\n");
        exit(1);
    }
    tmp->kind = is_TSimp;
    tmp->u.tsimp_.iden_ = p1;
    return tmp;
}

/********************   TCov    ********************/

TypeArg make_TCov(Iden p1, Type p2)
{
    TypeArg tmp = (TypeArg) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TCov!\n");
        exit(1);
    }
    tmp->kind = is_TCov;
    tmp->u.tcov_.iden_ = p1;
    tmp->u.tcov_.type_ = p2;
    return tmp;
}

/********************   TContra    ********************/

TypeArg make_TContra(Iden p1, Type p2)
{
    TypeArg tmp = (TypeArg) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TContra!\n");
        exit(1);
    }
    tmp->kind = is_TContra;
    tmp->u.tcontra_.iden_ = p1;
    tmp->u.tcontra_.type_ = p2;
    return tmp;
}

/********************   ListTypeArg    ********************/

ListTypeArg make_ListTypeArg(TypeArg p1, ListTypeArg p2)
{
    ListTypeArg tmp = (ListTypeArg) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListTypeArg!\n");
        exit(1);
    }
    tmp->typearg_ = p1;
    tmp->listtypearg_ = p2;
    return tmp;
}

/********************   TNil    ********************/

TArgsDecl make_TNil()
{
    TArgsDecl tmp = (TArgsDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TNil!\n");
        exit(1);
    }
    tmp->kind = is_TNil;
    return tmp;
}

/********************   TDecl    ********************/

TArgsDecl make_TDecl(ListTypeArg p1)
{
    TArgsDecl tmp = (TArgsDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TDecl!\n");
        exit(1);
    }
    tmp->kind = is_TDecl;
    tmp->u.tdecl_.listtypearg_ = p1;
    return tmp;
}

/********************   FFunc    ********************/

FuncDecl make_FFunc(ListPropDecl p1, Iden p2, TArgsDecl p3, ListParaSig p4, Type p5, FuncBody p6)
{
    FuncDecl tmp = (FuncDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FFunc!\n");
        exit(1);
    }
    tmp->kind = is_FFunc;
    tmp->u.ffunc_.listpropdecl_ = p1;
    tmp->u.ffunc_.iden_ = p2;
    tmp->u.ffunc_.targsdecl_ = p3;
    tmp->u.ffunc_.listparasig_ = p4;
    tmp->u.ffunc_.type_ = p5;
    tmp->u.ffunc_.funcbody_ = p6;
    return tmp;
}

/********************   FAbsBody    ********************/

FuncBody make_FAbsBody()
{
    FuncBody tmp = (FuncBody) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FAbsBody!\n");
        exit(1);
    }
    tmp->kind = is_FAbsBody;
    return tmp;
}

/********************   FConBody    ********************/

FuncBody make_FConBody(StmtBlock p1)
{
    FuncBody tmp = (FuncBody) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FConBody!\n");
        exit(1);
    }
    tmp->kind = is_FConBody;
    tmp->u.fconbody_.stmtblock_ = p1;
    return tmp;
}

/********************   PSig    ********************/

ParaSig make_PSig(Iden p1, Type p2)
{
    ParaSig tmp = (ParaSig) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PSig!\n");
        exit(1);
    }
    tmp->kind = is_PSig;
    tmp->u.psig_.iden_ = p1;
    tmp->u.psig_.type_ = p2;
    return tmp;
}

/********************   ListParaSig    ********************/

ListParaSig make_ListParaSig(ParaSig p1, ListParaSig p2)
{
    ListParaSig tmp = (ListParaSig) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListParaSig!\n");
        exit(1);
    }
    tmp->parasig_ = p1;
    tmp->listparasig_ = p2;
    return tmp;
}

/********************   CClass    ********************/

ClassDecl make_CClass(ListPropDecl p1, Iden p2, TArgsDecl p3, Inhrt p4, ListClassMemDecl p5)
{
    ClassDecl tmp = (ClassDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CClass!\n");
        exit(1);
    }
    tmp->kind = is_CClass;
    tmp->u.cclass_.listpropdecl_ = p1;
    tmp->u.cclass_.iden_ = p2;
    tmp->u.cclass_.targsdecl_ = p3;
    tmp->u.cclass_.inhrt_ = p4;
    tmp->u.cclass_.listclassmemdecl_ = p5;
    return tmp;
}

/********************   CInter    ********************/

ClassDecl make_CInter(ListPropDecl p1, TArgsDecl p2, Iden p3, Inhrt p4, ListClassMemDecl p5)
{
    ClassDecl tmp = (ClassDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CInter!\n");
        exit(1);
    }
    tmp->kind = is_CInter;
    tmp->u.cinter_.listpropdecl_ = p1;
    tmp->u.cinter_.targsdecl_ = p2;
    tmp->u.cinter_.iden_ = p3;
    tmp->u.cinter_.inhrt_ = p4;
    tmp->u.cinter_.listclassmemdecl_ = p5;
    return tmp;
}

/********************   INoInherit    ********************/

Inhrt make_INoInherit()
{
    Inhrt tmp = (Inhrt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating INoInherit!\n");
        exit(1);
    }
    tmp->kind = is_INoInherit;
    return tmp;
}

/********************   IInherit    ********************/

Inhrt make_IInherit(ListCType p1)
{
    Inhrt tmp = (Inhrt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating IInherit!\n");
        exit(1);
    }
    tmp->kind = is_IInherit;
    tmp->u.iinherit_.listctype_ = p1;
    return tmp;
}

/********************   PName    ********************/

Prop make_PName(Iden p1)
{
    Prop tmp = (Prop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PName!\n");
        exit(1);
    }
    tmp->kind = is_PName;
    tmp->u.pname_.iden_ = p1;
    return tmp;
}

/********************   PProp    ********************/

PropDecl make_PProp(ListProp p1)
{
    PropDecl tmp = (PropDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PProp!\n");
        exit(1);
    }
    tmp->kind = is_PProp;
    tmp->u.pprop_.listprop_ = p1;
    return tmp;
}

/********************   ListProp    ********************/

ListProp make_ListProp(Prop p1, ListProp p2)
{
    ListProp tmp = (ListProp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListProp!\n");
        exit(1);
    }
    tmp->prop_ = p1;
    tmp->listprop_ = p2;
    return tmp;
}

/********************   ListPropDecl    ********************/

ListPropDecl make_ListPropDecl(PropDecl p1, ListPropDecl p2)
{
    ListPropDecl tmp = (ListPropDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListPropDecl!\n");
        exit(1);
    }
    tmp->propdecl_ = p1;
    tmp->listpropdecl_ = p2;
    return tmp;
}

/********************   VSig    ********************/

VarSig make_VSig(ListIden p1, Type p2)
{
    VarSig tmp = (VarSig) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VSig!\n");
        exit(1);
    }
    tmp->kind = is_VSig;
    tmp->u.vsig_.listiden_ = p1;
    tmp->u.vsig_.type_ = p2;
    return tmp;
}

/********************   VNoAsn    ********************/

VarDef make_VNoAsn(VarSig p1)
{
    VarDef tmp = (VarDef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VNoAsn!\n");
        exit(1);
    }
    tmp->kind = is_VNoAsn;
    tmp->u.vnoasn_.varsig_ = p1;
    return tmp;
}

/********************   VAsn    ********************/

VarDef make_VAsn(VarSig p1, ListExp p2)
{
    VarDef tmp = (VarDef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VAsn!\n");
        exit(1);
    }
    tmp->kind = is_VAsn;
    tmp->u.vasn_.varsig_ = p1;
    tmp->u.vasn_.listexp_ = p2;
    return tmp;
}

/********************   MPropVar    ********************/

GVarDef make_MPropVar(ListPropDecl p1, VarDef p2)
{
    GVarDef tmp = (GVarDef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MPropVar!\n");
        exit(1);
    }
    tmp->kind = is_MPropVar;
    tmp->u.mpropvar_.listpropdecl_ = p1;
    tmp->u.mpropvar_.vardef_ = p2;
    return tmp;
}

/********************   CSimp    ********************/

CType make_CSimp(Iden p1)
{
    CType tmp = (CType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CSimp!\n");
        exit(1);
    }
    tmp->kind = is_CSimp;
    tmp->u.csimp_.iden_ = p1;
    return tmp;
}

/********************   CGen    ********************/

CType make_CGen(Iden p1, ListType p2)
{
    CType tmp = (CType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CGen!\n");
        exit(1);
    }
    tmp->kind = is_CGen;
    tmp->u.cgen_.iden_ = p1;
    tmp->u.cgen_.listtype_ = p2;
    return tmp;
}

/********************   CList    ********************/

CType make_CList(Type p1)
{
    CType tmp = (CType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CList!\n");
        exit(1);
    }
    tmp->kind = is_CList;
    tmp->u.clist_.type_ = p1;
    return tmp;
}

/********************   CTup    ********************/

CType make_CTup(ListType p1)
{
    CType tmp = (CType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CTup!\n");
        exit(1);
    }
    tmp->kind = is_CTup;
    tmp->u.ctup_.listtype_ = p1;
    return tmp;
}

/********************   ListCType    ********************/

ListCType make_ListCType(CType p1, ListCType p2)
{
    ListCType tmp = (ListCType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListCType!\n");
        exit(1);
    }
    tmp->ctype_ = p1;
    tmp->listctype_ = p2;
    return tmp;
}

/********************   TMaybe    ********************/

Type make_TMaybe(CType p1)
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TMaybe!\n");
        exit(1);
    }
    tmp->kind = is_TMaybe;
    tmp->u.tmaybe_.ctype_ = p1;
    return tmp;
}

/********************   TPure    ********************/

Type make_TPure(CType p1)
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TPure!\n");
        exit(1);
    }
    tmp->kind = is_TPure;
    tmp->u.tpure_.ctype_ = p1;
    return tmp;
}

/********************   ListType    ********************/

ListType make_ListType(Type p1, ListType p2)
{
    ListType tmp = (ListType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListType!\n");
        exit(1);
    }
    tmp->type_ = p1;
    tmp->listtype_ = p2;
    return tmp;
}

/********************   LInt    ********************/

Lit make_LInt(Integer p1)
{
    Lit tmp = (Lit) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LInt!\n");
        exit(1);
    }
    tmp->kind = is_LInt;
    tmp->u.lint_.integer_ = p1;
    return tmp;
}

/********************   LStr    ********************/

Lit make_LStr(String p1)
{
    Lit tmp = (Lit) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LStr!\n");
        exit(1);
    }
    tmp->kind = is_LStr;
    tmp->u.lstr_.string_ = p1;
    return tmp;
}

/********************   LChr    ********************/

Lit make_LChr(Char p1)
{
    Lit tmp = (Lit) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LChr!\n");
        exit(1);
    }
    tmp->kind = is_LChr;
    tmp->u.lchr_.char_ = p1;
    return tmp;
}

/********************   LFlo    ********************/

Lit make_LFlo(Double p1)
{
    Lit tmp = (Lit) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LFlo!\n");
        exit(1);
    }
    tmp->kind = is_LFlo;
    tmp->u.lflo_.double_ = p1;
    return tmp;
}

/********************   Asn    ********************/

Op make_Asn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Asn!\n");
        exit(1);
    }
    tmp->kind = is_Asn;
    return tmp;
}

/********************   AddAsn    ********************/

Op make_AddAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AddAsn!\n");
        exit(1);
    }
    tmp->kind = is_AddAsn;
    return tmp;
}

/********************   SubAsn    ********************/

Op make_SubAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SubAsn!\n");
        exit(1);
    }
    tmp->kind = is_SubAsn;
    return tmp;
}

/********************   MulAsn    ********************/

Op make_MulAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MulAsn!\n");
        exit(1);
    }
    tmp->kind = is_MulAsn;
    return tmp;
}

/********************   DivAsn    ********************/

Op make_DivAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating DivAsn!\n");
        exit(1);
    }
    tmp->kind = is_DivAsn;
    return tmp;
}

/********************   ModAsn    ********************/

Op make_ModAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ModAsn!\n");
        exit(1);
    }
    tmp->kind = is_ModAsn;
    return tmp;
}

/********************   AndAsn    ********************/

Op make_AndAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AndAsn!\n");
        exit(1);
    }
    tmp->kind = is_AndAsn;
    return tmp;
}

/********************   XorAsn    ********************/

Op make_XorAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating XorAsn!\n");
        exit(1);
    }
    tmp->kind = is_XorAsn;
    return tmp;
}

/********************   OrAsn    ********************/

Op make_OrAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OrAsn!\n");
        exit(1);
    }
    tmp->kind = is_OrAsn;
    return tmp;
}

/********************   ShlAsn    ********************/

Op make_ShlAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ShlAsn!\n");
        exit(1);
    }
    tmp->kind = is_ShlAsn;
    return tmp;
}

/********************   ShrAsn    ********************/

Op make_ShrAsn()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ShrAsn!\n");
        exit(1);
    }
    tmp->kind = is_ShrAsn;
    return tmp;
}

/********************   LogOr    ********************/

Op make_LogOr()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LogOr!\n");
        exit(1);
    }
    tmp->kind = is_LogOr;
    return tmp;
}

/********************   LogAnd    ********************/

Op make_LogAnd()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LogAnd!\n");
        exit(1);
    }
    tmp->kind = is_LogAnd;
    return tmp;
}

/********************   BitOr    ********************/

Op make_BitOr()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BitOr!\n");
        exit(1);
    }
    tmp->kind = is_BitOr;
    return tmp;
}

/********************   BitXor    ********************/

Op make_BitXor()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BitXor!\n");
        exit(1);
    }
    tmp->kind = is_BitXor;
    return tmp;
}

/********************   BitAnd    ********************/

Op make_BitAnd()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BitAnd!\n");
        exit(1);
    }
    tmp->kind = is_BitAnd;
    return tmp;
}

/********************   NotEq    ********************/

Op make_NotEq()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NotEq!\n");
        exit(1);
    }
    tmp->kind = is_NotEq;
    return tmp;
}

/********************   Eq    ********************/

Op make_Eq()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Eq!\n");
        exit(1);
    }
    tmp->kind = is_Eq;
    return tmp;
}

/********************   Lt    ********************/

Op make_Lt()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Lt!\n");
        exit(1);
    }
    tmp->kind = is_Lt;
    return tmp;
}

/********************   Gt    ********************/

Op make_Gt()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Gt!\n");
        exit(1);
    }
    tmp->kind = is_Gt;
    return tmp;
}

/********************   Leq    ********************/

Op make_Leq()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Leq!\n");
        exit(1);
    }
    tmp->kind = is_Leq;
    return tmp;
}

/********************   Geq    ********************/

Op make_Geq()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Geq!\n");
        exit(1);
    }
    tmp->kind = is_Geq;
    return tmp;
}

/********************   Shl    ********************/

Op make_Shl()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Shl!\n");
        exit(1);
    }
    tmp->kind = is_Shl;
    return tmp;
}

/********************   Shr    ********************/

Op make_Shr()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Shr!\n");
        exit(1);
    }
    tmp->kind = is_Shr;
    return tmp;
}

/********************   Add    ********************/

Op make_Add()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Add!\n");
        exit(1);
    }
    tmp->kind = is_Add;
    return tmp;
}

/********************   Sub    ********************/

Op make_Sub()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Sub!\n");
        exit(1);
    }
    tmp->kind = is_Sub;
    return tmp;
}

/********************   Mul    ********************/

Op make_Mul()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Mul!\n");
        exit(1);
    }
    tmp->kind = is_Mul;
    return tmp;
}

/********************   Div    ********************/

Op make_Div()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Div!\n");
        exit(1);
    }
    tmp->kind = is_Div;
    return tmp;
}

/********************   Mod    ********************/

Op make_Mod()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Mod!\n");
        exit(1);
    }
    tmp->kind = is_Mod;
    return tmp;
}

/********************   Pow    ********************/

Op make_Pow()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Pow!\n");
        exit(1);
    }
    tmp->kind = is_Pow;
    return tmp;
}

/********************   Ref    ********************/

Op make_Ref()
{
    Op tmp = (Op) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Ref!\n");
        exit(1);
    }
    tmp->kind = is_Ref;
    return tmp;
}

/********************   SExp    ********************/

Stmt make_SExp(Exp p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SExp!\n");
        exit(1);
    }
    tmp->kind = is_SExp;
    tmp->u.sexp_.exp_ = p1;
    return tmp;
}

/********************   SDecl    ********************/

Stmt make_SDecl(VarDef p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SDecl!\n");
        exit(1);
    }
    tmp->kind = is_SDecl;
    tmp->u.sdecl_.vardef_ = p1;
    return tmp;
}

/********************   SRetNil    ********************/

Stmt make_SRetNil()
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SRetNil!\n");
        exit(1);
    }
    tmp->kind = is_SRetNil;
    return tmp;
}

/********************   SRet    ********************/

Stmt make_SRet(Exp p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SRet!\n");
        exit(1);
    }
    tmp->kind = is_SRet;
    tmp->u.sret_.exp_ = p1;
    return tmp;
}

/********************   SBreak    ********************/

Stmt make_SBreak()
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SBreak!\n");
        exit(1);
    }
    tmp->kind = is_SBreak;
    return tmp;
}

/********************   SCont    ********************/

Stmt make_SCont()
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SCont!\n");
        exit(1);
    }
    tmp->kind = is_SCont;
    return tmp;
}

/********************   SIf    ********************/

Stmt make_SIf(AliasIf p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SIf!\n");
        exit(1);
    }
    tmp->kind = is_SIf;
    tmp->u.sif_.aliasif_ = p1;
    return tmp;
}

/********************   SFor    ********************/

Stmt make_SFor(Iden p1, Exp p2, StmtBlock p3)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SFor!\n");
        exit(1);
    }
    tmp->kind = is_SFor;
    tmp->u.sfor_.iden_ = p1;
    tmp->u.sfor_.exp_ = p2;
    tmp->u.sfor_.stmtblock_ = p3;
    return tmp;
}

/********************   SWhile    ********************/

Stmt make_SWhile(Exp p1, StmtBlock p2)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SWhile!\n");
        exit(1);
    }
    tmp->kind = is_SWhile;
    tmp->u.swhile_.exp_ = p1;
    tmp->u.swhile_.stmtblock_ = p2;
    return tmp;
}

/********************   EEmpty    ********************/

Else make_EEmpty()
{
    Else tmp = (Else) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EEmpty!\n");
        exit(1);
    }
    tmp->kind = is_EEmpty;
    return tmp;
}

/********************   EElse    ********************/

Else make_EElse(StmtBlock p1)
{
    Else tmp = (Else) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EElse!\n");
        exit(1);
    }
    tmp->kind = is_EElse;
    tmp->u.eelse_.stmtblock_ = p1;
    return tmp;
}

/********************   EElif    ********************/

Else make_EElif(AliasIf p1)
{
    Else tmp = (Else) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EElif!\n");
        exit(1);
    }
    tmp->kind = is_EElif;
    tmp->u.eelif_.aliasif_ = p1;
    return tmp;
}

/********************   AIf    ********************/

AliasIf make_AIf(Exp p1, StmtBlock p2, Else p3)
{
    AliasIf tmp = (AliasIf) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AIf!\n");
        exit(1);
    }
    tmp->kind = is_AIf;
    tmp->u.aif_.exp_ = p1;
    tmp->u.aif_.stmtblock_ = p2;
    tmp->u.aif_.else_ = p3;
    return tmp;
}

/********************   ListStmt    ********************/

ListStmt make_ListStmt(Stmt p1, ListStmt p2)
{
    ListStmt tmp = (ListStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListStmt!\n");
        exit(1);
    }
    tmp->stmt_ = p1;
    tmp->liststmt_ = p2;
    return tmp;
}

/********************   SStmt    ********************/

StmtBlock make_SStmt(ListStmt p1)
{
    StmtBlock tmp = (StmtBlock) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SStmt!\n");
        exit(1);
    }
    tmp->kind = is_SStmt;
    tmp->u.sstmt_.liststmt_ = p1;
    return tmp;
}

/********************   EOp    ********************/

Exp make_EOp(Exp p1, Op p2, Exp p3)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EOp!\n");
        exit(1);
    }
    tmp->kind = is_EOp;
    tmp->u.eop_.exp_1 = p1;
    tmp->u.eop_.op_ = p2;
    tmp->u.eop_.exp_2 = p3;
    return tmp;
}

/********************   PreInc    ********************/

Exp make_PreInc(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PreInc!\n");
        exit(1);
    }
    tmp->kind = is_PreInc;
    tmp->u.preinc_.exp_ = p1;
    return tmp;
}

/********************   PreDec    ********************/

Exp make_PreDec(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PreDec!\n");
        exit(1);
    }
    tmp->kind = is_PreDec;
    tmp->u.predec_.exp_ = p1;
    return tmp;
}

/********************   Pos    ********************/

Exp make_Pos(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Pos!\n");
        exit(1);
    }
    tmp->kind = is_Pos;
    tmp->u.pos_.exp_ = p1;
    return tmp;
}

/********************   Neg    ********************/

Exp make_Neg(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Neg!\n");
        exit(1);
    }
    tmp->kind = is_Neg;
    tmp->u.neg_.exp_ = p1;
    return tmp;
}

/********************   LogNot    ********************/

Exp make_LogNot(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LogNot!\n");
        exit(1);
    }
    tmp->kind = is_LogNot;
    tmp->u.lognot_.exp_ = p1;
    return tmp;
}

/********************   BitNot    ********************/

Exp make_BitNot(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BitNot!\n");
        exit(1);
    }
    tmp->kind = is_BitNot;
    tmp->u.bitnot_.exp_ = p1;
    return tmp;
}

/********************   SufInc    ********************/

Exp make_SufInc(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SufInc!\n");
        exit(1);
    }
    tmp->kind = is_SufInc;
    tmp->u.sufinc_.exp_ = p1;
    return tmp;
}

/********************   SufDec    ********************/

Exp make_SufDec(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SufDec!\n");
        exit(1);
    }
    tmp->kind = is_SufDec;
    tmp->u.sufdec_.exp_ = p1;
    return tmp;
}

/********************   ArrIdx    ********************/

Exp make_ArrIdx(Exp p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ArrIdx!\n");
        exit(1);
    }
    tmp->kind = is_ArrIdx;
    tmp->u.arridx_.exp_1 = p1;
    tmp->u.arridx_.exp_2 = p2;
    return tmp;
}

/********************   FuncCall    ********************/

Exp make_FuncCall(Exp p1, TArgsPass p2, ListExp p3)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FuncCall!\n");
        exit(1);
    }
    tmp->kind = is_FuncCall;
    tmp->u.funccall_.exp_ = p1;
    tmp->u.funccall_.targspass_ = p2;
    tmp->u.funccall_.listexp_ = p3;
    return tmp;
}

/********************   ELit    ********************/

Exp make_ELit(Lit p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ELit!\n");
        exit(1);
    }
    tmp->kind = is_ELit;
    tmp->u.elit_.lit_ = p1;
    return tmp;
}

/********************   EIde    ********************/

Exp make_EIde(Iden p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EIde!\n");
        exit(1);
    }
    tmp->kind = is_EIde;
    tmp->u.eide_.iden_ = p1;
    return tmp;
}

/********************   ENil    ********************/

Exp make_ENil()
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ENil!\n");
        exit(1);
    }
    tmp->kind = is_ENil;
    return tmp;
}

/********************   ESing    ********************/

Exp make_ESing(Iden p1, LamBody p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ESing!\n");
        exit(1);
    }
    tmp->kind = is_ESing;
    tmp->u.esing_.iden_ = p1;
    tmp->u.esing_.lambody_ = p2;
    return tmp;
}

/********************   EMore    ********************/

Exp make_EMore(ListIden p1, LamBody p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EMore!\n");
        exit(1);
    }
    tmp->kind = is_EMore;
    tmp->u.emore_.listiden_ = p1;
    tmp->u.emore_.lambody_ = p2;
    return tmp;
}

/********************   ETupOne    ********************/

Exp make_ETupOne(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ETupOne!\n");
        exit(1);
    }
    tmp->kind = is_ETupOne;
    tmp->u.etupone_.exp_ = p1;
    return tmp;
}

/********************   ETupTwo    ********************/

Exp make_ETupTwo(Exp p1, Exp p2, OptionExp p3)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ETupTwo!\n");
        exit(1);
    }
    tmp->kind = is_ETupTwo;
    tmp->u.etuptwo_.exp_1 = p1;
    tmp->u.etuptwo_.exp_2 = p2;
    tmp->u.etuptwo_.optionexp_ = p3;
    return tmp;
}

/********************   EList    ********************/

Exp make_EList(ListExp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EList!\n");
        exit(1);
    }
    tmp->kind = is_EList;
    tmp->u.elist_.listexp_ = p1;
    return tmp;
}

/********************   TPNil    ********************/

TArgsPass make_TPNil()
{
    TArgsPass tmp = (TArgsPass) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TPNil!\n");
        exit(1);
    }
    tmp->kind = is_TPNil;
    return tmp;
}

/********************   TPass    ********************/

TArgsPass make_TPass(ListType p1)
{
    TArgsPass tmp = (TArgsPass) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TPass!\n");
        exit(1);
    }
    tmp->kind = is_TPass;
    tmp->u.tpass_.listtype_ = p1;
    return tmp;
}

/********************   ListExp    ********************/

ListExp make_ListExp(Exp p1, ListExp p2)
{
    ListExp tmp = (ListExp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListExp!\n");
        exit(1);
    }
    tmp->exp_ = p1;
    tmp->listexp_ = p2;
    return tmp;
}

/********************   ONil    ********************/

OptionExp make_ONil()
{
    OptionExp tmp = (OptionExp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ONil!\n");
        exit(1);
    }
    tmp->kind = is_ONil;
    return tmp;
}

/********************   OExp    ********************/

OptionExp make_OExp(ListExp p1)
{
    OptionExp tmp = (OptionExp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OExp!\n");
        exit(1);
    }
    tmp->kind = is_OExp;
    tmp->u.oexp_.listexp_ = p1;
    return tmp;
}

/********************   LExp    ********************/

LamBody make_LExp(Exp p1)
{
    LamBody tmp = (LamBody) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LExp!\n");
        exit(1);
    }
    tmp->kind = is_LExp;
    tmp->u.lexp_.exp_ = p1;
    return tmp;
}

/********************   LStm    ********************/

LamBody make_LStm(StmtBlock p1)
{
    LamBody tmp = (LamBody) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LStm!\n");
        exit(1);
    }
    tmp->kind = is_LStm;
    tmp->u.lstm_.stmtblock_ = p1;
    return tmp;
}

/***************************   Cloning   ******************************/

ListIden clone_ListIden(ListIden listiden)
{
  if (listiden)
  {
    /* clone of non-empty list */
    return make_ListIden
      ( strdup(listiden->iden_)
      , clone_ListIden(listiden->listiden_)
      );
  }
  else return NULL; /* clone of empty list */
}

Program clone_Program(Program p)
{
  switch(p->kind)
  {
  case is_Prog:
    return make_Prog (clone_ListGlobDecl(p->u.prog_.listglobdecl_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Program!\n");
    exit(1);
  }
}

GlobDecl clone_GlobDecl(GlobDecl p)
{
  switch(p->kind)
  {
  case is_GMemDecl:
    return make_GMemDecl (clone_ClassMemDecl(p->u.gmemdecl_.classmemdecl_));

  case is_GClassDecl:
    return make_GClassDecl (clone_ClassDecl(p->u.gclassdecl_.classdecl_));

  case is_GImport:
    return make_GImport (clone_ImportDecl(p->u.gimport_.importdecl_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning GlobDecl!\n");
    exit(1);
  }
}

ListGlobDecl clone_ListGlobDecl(ListGlobDecl listglobdecl)
{
  if (listglobdecl)
  {
    /* clone of non-empty list */
    return make_ListGlobDecl
      ( clone_GlobDecl(listglobdecl->globdecl_)
      , clone_ListGlobDecl(listglobdecl->listglobdecl_)
      );
  }
  else return NULL; /* clone of empty list */
}

ImportDecl clone_ImportDecl(ImportDecl p)
{
  switch(p->kind)
  {
  case is_IImport:
    return make_IImport
      ( clone_ListPropDecl(p->u.iimport_.listpropdecl_)
      , clone_ListPack(p->u.iimport_.listpack_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ImportDecl!\n");
    exit(1);
  }
}

Pack clone_Pack(Pack p)
{
  switch(p->kind)
  {
  case is_PackName:
    return make_PackName (strdup(p->u.packname_.iden_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Pack!\n");
    exit(1);
  }
}

ListPack clone_ListPack(ListPack listpack)
{
  if (listpack)
  {
    /* clone of non-empty list */
    return make_ListPack
      ( clone_Pack(listpack->pack_)
      , clone_ListPack(listpack->listpack_)
      );
  }
  else return NULL; /* clone of empty list */
}

ClassMemDecl clone_ClassMemDecl(ClassMemDecl p)
{
  switch(p->kind)
  {
  case is_CVarDecl:
    return make_CVarDecl (clone_GVarDef(p->u.cvardecl_.gvardef_));

  case is_CFuncDecl:
    return make_CFuncDecl (clone_FuncDecl(p->u.cfuncdecl_.funcdecl_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning ClassMemDecl!\n");
    exit(1);
  }
}

ListClassMemDecl clone_ListClassMemDecl(ListClassMemDecl listclassmemdecl)
{
  if (listclassmemdecl)
  {
    /* clone of non-empty list */
    return make_ListClassMemDecl
      ( clone_ClassMemDecl(listclassmemdecl->classmemdecl_)
      , clone_ListClassMemDecl(listclassmemdecl->listclassmemdecl_)
      );
  }
  else return NULL; /* clone of empty list */
}

TypeArg clone_TypeArg(TypeArg p)
{
  switch(p->kind)
  {
  case is_TSimp:
    return make_TSimp (strdup(p->u.tsimp_.iden_));

  case is_TCov:
    return make_TCov
      ( strdup(p->u.tcov_.iden_)
      , clone_Type(p->u.tcov_.type_)
      );

  case is_TContra:
    return make_TContra
      ( strdup(p->u.tcontra_.iden_)
      , clone_Type(p->u.tcontra_.type_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning TypeArg!\n");
    exit(1);
  }
}

ListTypeArg clone_ListTypeArg(ListTypeArg listtypearg)
{
  if (listtypearg)
  {
    /* clone of non-empty list */
    return make_ListTypeArg
      ( clone_TypeArg(listtypearg->typearg_)
      , clone_ListTypeArg(listtypearg->listtypearg_)
      );
  }
  else return NULL; /* clone of empty list */
}

TArgsDecl clone_TArgsDecl(TArgsDecl p)
{
  switch(p->kind)
  {
  case is_TNil:
    return make_TNil ();

  case is_TDecl:
    return make_TDecl (clone_ListTypeArg(p->u.tdecl_.listtypearg_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning TArgsDecl!\n");
    exit(1);
  }
}

FuncDecl clone_FuncDecl(FuncDecl p)
{
  switch(p->kind)
  {
  case is_FFunc:
    return make_FFunc
      ( clone_ListPropDecl(p->u.ffunc_.listpropdecl_)
      , strdup(p->u.ffunc_.iden_)
      , clone_TArgsDecl(p->u.ffunc_.targsdecl_)
      , clone_ListParaSig(p->u.ffunc_.listparasig_)
      , clone_Type(p->u.ffunc_.type_)
      , clone_FuncBody(p->u.ffunc_.funcbody_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning FuncDecl!\n");
    exit(1);
  }
}

FuncBody clone_FuncBody(FuncBody p)
{
  switch(p->kind)
  {
  case is_FAbsBody:
    return make_FAbsBody ();

  case is_FConBody:
    return make_FConBody (clone_StmtBlock(p->u.fconbody_.stmtblock_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning FuncBody!\n");
    exit(1);
  }
}

ParaSig clone_ParaSig(ParaSig p)
{
  switch(p->kind)
  {
  case is_PSig:
    return make_PSig
      ( strdup(p->u.psig_.iden_)
      , clone_Type(p->u.psig_.type_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ParaSig!\n");
    exit(1);
  }
}

ListParaSig clone_ListParaSig(ListParaSig listparasig)
{
  if (listparasig)
  {
    /* clone of non-empty list */
    return make_ListParaSig
      ( clone_ParaSig(listparasig->parasig_)
      , clone_ListParaSig(listparasig->listparasig_)
      );
  }
  else return NULL; /* clone of empty list */
}

ClassDecl clone_ClassDecl(ClassDecl p)
{
  switch(p->kind)
  {
  case is_CClass:
    return make_CClass
      ( clone_ListPropDecl(p->u.cclass_.listpropdecl_)
      , strdup(p->u.cclass_.iden_)
      , clone_TArgsDecl(p->u.cclass_.targsdecl_)
      , clone_Inhrt(p->u.cclass_.inhrt_)
      , clone_ListClassMemDecl(p->u.cclass_.listclassmemdecl_)
      );

  case is_CInter:
    return make_CInter
      ( clone_ListPropDecl(p->u.cinter_.listpropdecl_)
      , clone_TArgsDecl(p->u.cinter_.targsdecl_)
      , strdup(p->u.cinter_.iden_)
      , clone_Inhrt(p->u.cinter_.inhrt_)
      , clone_ListClassMemDecl(p->u.cinter_.listclassmemdecl_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ClassDecl!\n");
    exit(1);
  }
}

Inhrt clone_Inhrt(Inhrt p)
{
  switch(p->kind)
  {
  case is_INoInherit:
    return make_INoInherit ();

  case is_IInherit:
    return make_IInherit (clone_ListCType(p->u.iinherit_.listctype_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Inhrt!\n");
    exit(1);
  }
}

Prop clone_Prop(Prop p)
{
  switch(p->kind)
  {
  case is_PName:
    return make_PName (strdup(p->u.pname_.iden_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Prop!\n");
    exit(1);
  }
}

PropDecl clone_PropDecl(PropDecl p)
{
  switch(p->kind)
  {
  case is_PProp:
    return make_PProp (clone_ListProp(p->u.pprop_.listprop_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning PropDecl!\n");
    exit(1);
  }
}

ListProp clone_ListProp(ListProp listprop)
{
  if (listprop)
  {
    /* clone of non-empty list */
    return make_ListProp
      ( clone_Prop(listprop->prop_)
      , clone_ListProp(listprop->listprop_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListPropDecl clone_ListPropDecl(ListPropDecl listpropdecl)
{
  if (listpropdecl)
  {
    /* clone of non-empty list */
    return make_ListPropDecl
      ( clone_PropDecl(listpropdecl->propdecl_)
      , clone_ListPropDecl(listpropdecl->listpropdecl_)
      );
  }
  else return NULL; /* clone of empty list */
}

VarSig clone_VarSig(VarSig p)
{
  switch(p->kind)
  {
  case is_VSig:
    return make_VSig
      ( clone_ListIden(p->u.vsig_.listiden_)
      , clone_Type(p->u.vsig_.type_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning VarSig!\n");
    exit(1);
  }
}

VarDef clone_VarDef(VarDef p)
{
  switch(p->kind)
  {
  case is_VNoAsn:
    return make_VNoAsn (clone_VarSig(p->u.vnoasn_.varsig_));

  case is_VAsn:
    return make_VAsn
      ( clone_VarSig(p->u.vasn_.varsig_)
      , clone_ListExp(p->u.vasn_.listexp_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning VarDef!\n");
    exit(1);
  }
}

GVarDef clone_GVarDef(GVarDef p)
{
  switch(p->kind)
  {
  case is_MPropVar:
    return make_MPropVar
      ( clone_ListPropDecl(p->u.mpropvar_.listpropdecl_)
      , clone_VarDef(p->u.mpropvar_.vardef_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning GVarDef!\n");
    exit(1);
  }
}

CType clone_CType(CType p)
{
  switch(p->kind)
  {
  case is_CSimp:
    return make_CSimp (strdup(p->u.csimp_.iden_));

  case is_CGen:
    return make_CGen
      ( strdup(p->u.cgen_.iden_)
      , clone_ListType(p->u.cgen_.listtype_)
      );

  case is_CList:
    return make_CList (clone_Type(p->u.clist_.type_));

  case is_CTup:
    return make_CTup (clone_ListType(p->u.ctup_.listtype_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning CType!\n");
    exit(1);
  }
}

ListCType clone_ListCType(ListCType listctype)
{
  if (listctype)
  {
    /* clone of non-empty list */
    return make_ListCType
      ( clone_CType(listctype->ctype_)
      , clone_ListCType(listctype->listctype_)
      );
  }
  else return NULL; /* clone of empty list */
}

Type clone_Type(Type p)
{
  switch(p->kind)
  {
  case is_TMaybe:
    return make_TMaybe (clone_CType(p->u.tmaybe_.ctype_));

  case is_TPure:
    return make_TPure (clone_CType(p->u.tpure_.ctype_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Type!\n");
    exit(1);
  }
}

ListType clone_ListType(ListType listtype)
{
  if (listtype)
  {
    /* clone of non-empty list */
    return make_ListType
      ( clone_Type(listtype->type_)
      , clone_ListType(listtype->listtype_)
      );
  }
  else return NULL; /* clone of empty list */
}

Lit clone_Lit(Lit p)
{
  switch(p->kind)
  {
  case is_LInt:
    return make_LInt (p->u.lint_.integer_);

  case is_LStr:
    return make_LStr (strdup(p->u.lstr_.string_));

  case is_LChr:
    return make_LChr (p->u.lchr_.char_);

  case is_LFlo:
    return make_LFlo (p->u.lflo_.double_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning Lit!\n");
    exit(1);
  }
}

Op clone_Op(Op p)
{
  switch(p->kind)
  {
  case is_Asn:
    return make_Asn ();

  case is_AddAsn:
    return make_AddAsn ();

  case is_SubAsn:
    return make_SubAsn ();

  case is_MulAsn:
    return make_MulAsn ();

  case is_DivAsn:
    return make_DivAsn ();

  case is_ModAsn:
    return make_ModAsn ();

  case is_AndAsn:
    return make_AndAsn ();

  case is_XorAsn:
    return make_XorAsn ();

  case is_OrAsn:
    return make_OrAsn ();

  case is_ShlAsn:
    return make_ShlAsn ();

  case is_ShrAsn:
    return make_ShrAsn ();

  case is_LogOr:
    return make_LogOr ();

  case is_LogAnd:
    return make_LogAnd ();

  case is_BitOr:
    return make_BitOr ();

  case is_BitXor:
    return make_BitXor ();

  case is_BitAnd:
    return make_BitAnd ();

  case is_NotEq:
    return make_NotEq ();

  case is_Eq:
    return make_Eq ();

  case is_Lt:
    return make_Lt ();

  case is_Gt:
    return make_Gt ();

  case is_Leq:
    return make_Leq ();

  case is_Geq:
    return make_Geq ();

  case is_Shl:
    return make_Shl ();

  case is_Shr:
    return make_Shr ();

  case is_Add:
    return make_Add ();

  case is_Sub:
    return make_Sub ();

  case is_Mul:
    return make_Mul ();

  case is_Div:
    return make_Div ();

  case is_Mod:
    return make_Mod ();

  case is_Pow:
    return make_Pow ();

  case is_Ref:
    return make_Ref ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Op!\n");
    exit(1);
  }
}

Stmt clone_Stmt(Stmt p)
{
  switch(p->kind)
  {
  case is_SExp:
    return make_SExp (clone_Exp(p->u.sexp_.exp_));

  case is_SDecl:
    return make_SDecl (clone_VarDef(p->u.sdecl_.vardef_));

  case is_SRetNil:
    return make_SRetNil ();

  case is_SRet:
    return make_SRet (clone_Exp(p->u.sret_.exp_));

  case is_SBreak:
    return make_SBreak ();

  case is_SCont:
    return make_SCont ();

  case is_SIf:
    return make_SIf (clone_AliasIf(p->u.sif_.aliasif_));

  case is_SFor:
    return make_SFor
      ( strdup(p->u.sfor_.iden_)
      , clone_Exp(p->u.sfor_.exp_)
      , clone_StmtBlock(p->u.sfor_.stmtblock_)
      );

  case is_SWhile:
    return make_SWhile
      ( clone_Exp(p->u.swhile_.exp_)
      , clone_StmtBlock(p->u.swhile_.stmtblock_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Stmt!\n");
    exit(1);
  }
}

Else clone_Else(Else p)
{
  switch(p->kind)
  {
  case is_EEmpty:
    return make_EEmpty ();

  case is_EElse:
    return make_EElse (clone_StmtBlock(p->u.eelse_.stmtblock_));

  case is_EElif:
    return make_EElif (clone_AliasIf(p->u.eelif_.aliasif_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Else!\n");
    exit(1);
  }
}

AliasIf clone_AliasIf(AliasIf p)
{
  switch(p->kind)
  {
  case is_AIf:
    return make_AIf
      ( clone_Exp(p->u.aif_.exp_)
      , clone_StmtBlock(p->u.aif_.stmtblock_)
      , clone_Else(p->u.aif_.else_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning AliasIf!\n");
    exit(1);
  }
}

ListStmt clone_ListStmt(ListStmt liststmt)
{
  if (liststmt)
  {
    /* clone of non-empty list */
    return make_ListStmt
      ( clone_Stmt(liststmt->stmt_)
      , clone_ListStmt(liststmt->liststmt_)
      );
  }
  else return NULL; /* clone of empty list */
}

StmtBlock clone_StmtBlock(StmtBlock p)
{
  switch(p->kind)
  {
  case is_SStmt:
    return make_SStmt (clone_ListStmt(p->u.sstmt_.liststmt_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning StmtBlock!\n");
    exit(1);
  }
}

Exp clone_Exp(Exp p)
{
  switch(p->kind)
  {
  case is_EOp:
    return make_EOp
      ( clone_Exp(p->u.eop_.exp_1)
      , clone_Op(p->u.eop_.op_)
      , clone_Exp(p->u.eop_.exp_2)
      );

  case is_PreInc:
    return make_PreInc (clone_Exp(p->u.preinc_.exp_));

  case is_PreDec:
    return make_PreDec (clone_Exp(p->u.predec_.exp_));

  case is_Pos:
    return make_Pos (clone_Exp(p->u.pos_.exp_));

  case is_Neg:
    return make_Neg (clone_Exp(p->u.neg_.exp_));

  case is_LogNot:
    return make_LogNot (clone_Exp(p->u.lognot_.exp_));

  case is_BitNot:
    return make_BitNot (clone_Exp(p->u.bitnot_.exp_));

  case is_SufInc:
    return make_SufInc (clone_Exp(p->u.sufinc_.exp_));

  case is_SufDec:
    return make_SufDec (clone_Exp(p->u.sufdec_.exp_));

  case is_ArrIdx:
    return make_ArrIdx
      ( clone_Exp(p->u.arridx_.exp_1)
      , clone_Exp(p->u.arridx_.exp_2)
      );

  case is_FuncCall:
    return make_FuncCall
      ( clone_Exp(p->u.funccall_.exp_)
      , clone_TArgsPass(p->u.funccall_.targspass_)
      , clone_ListExp(p->u.funccall_.listexp_)
      );

  case is_ELit:
    return make_ELit (clone_Lit(p->u.elit_.lit_));

  case is_EIde:
    return make_EIde (strdup(p->u.eide_.iden_));

  case is_ENil:
    return make_ENil ();

  case is_ESing:
    return make_ESing
      ( strdup(p->u.esing_.iden_)
      , clone_LamBody(p->u.esing_.lambody_)
      );

  case is_EMore:
    return make_EMore
      ( clone_ListIden(p->u.emore_.listiden_)
      , clone_LamBody(p->u.emore_.lambody_)
      );

  case is_ETupOne:
    return make_ETupOne (clone_Exp(p->u.etupone_.exp_));

  case is_ETupTwo:
    return make_ETupTwo
      ( clone_Exp(p->u.etuptwo_.exp_1)
      , clone_Exp(p->u.etuptwo_.exp_2)
      , clone_OptionExp(p->u.etuptwo_.optionexp_)
      );

  case is_EList:
    return make_EList (clone_ListExp(p->u.elist_.listexp_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Exp!\n");
    exit(1);
  }
}

TArgsPass clone_TArgsPass(TArgsPass p)
{
  switch(p->kind)
  {
  case is_TPNil:
    return make_TPNil ();

  case is_TPass:
    return make_TPass (clone_ListType(p->u.tpass_.listtype_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning TArgsPass!\n");
    exit(1);
  }
}

ListExp clone_ListExp(ListExp listexp)
{
  if (listexp)
  {
    /* clone of non-empty list */
    return make_ListExp
      ( clone_Exp(listexp->exp_)
      , clone_ListExp(listexp->listexp_)
      );
  }
  else return NULL; /* clone of empty list */
}

OptionExp clone_OptionExp(OptionExp p)
{
  switch(p->kind)
  {
  case is_ONil:
    return make_ONil ();

  case is_OExp:
    return make_OExp (clone_ListExp(p->u.oexp_.listexp_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning OptionExp!\n");
    exit(1);
  }
}

LamBody clone_LamBody(LamBody p)
{
  switch(p->kind)
  {
  case is_LExp:
    return make_LExp (clone_Exp(p->u.lexp_.exp_));

  case is_LStm:
    return make_LStm (clone_StmtBlock(p->u.lstm_.stmtblock_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning LamBody!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_ListIden(ListIden listiden)
{
  if (listiden)
  {
    free(listiden->iden_);
    free_ListIden(listiden->listiden_);
    free(listiden);
  }
}

void free_Program(Program p)
{
  switch(p->kind)
  {
  case is_Prog:
    free_ListGlobDecl(p->u.prog_.listglobdecl_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Program!\n");
    exit(1);
  }
  free(p);
}

void free_GlobDecl(GlobDecl p)
{
  switch(p->kind)
  {
  case is_GMemDecl:
    free_ClassMemDecl(p->u.gmemdecl_.classmemdecl_);
    break;

  case is_GClassDecl:
    free_ClassDecl(p->u.gclassdecl_.classdecl_);
    break;

  case is_GImport:
    free_ImportDecl(p->u.gimport_.importdecl_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing GlobDecl!\n");
    exit(1);
  }
  free(p);
}

void free_ListGlobDecl(ListGlobDecl listglobdecl)
{
  if (listglobdecl)
  {
    free_GlobDecl(listglobdecl->globdecl_);
    free_ListGlobDecl(listglobdecl->listglobdecl_);
    free(listglobdecl);
  }
}

void free_ImportDecl(ImportDecl p)
{
  switch(p->kind)
  {
  case is_IImport:
    free_ListPropDecl(p->u.iimport_.listpropdecl_);
    free_ListPack(p->u.iimport_.listpack_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ImportDecl!\n");
    exit(1);
  }
  free(p);
}

void free_Pack(Pack p)
{
  switch(p->kind)
  {
  case is_PackName:
    free(p->u.packname_.iden_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Pack!\n");
    exit(1);
  }
  free(p);
}

void free_ListPack(ListPack listpack)
{
  if (listpack)
  {
    free_Pack(listpack->pack_);
    free_ListPack(listpack->listpack_);
    free(listpack);
  }
}

void free_ClassMemDecl(ClassMemDecl p)
{
  switch(p->kind)
  {
  case is_CVarDecl:
    free_GVarDef(p->u.cvardecl_.gvardef_);
    break;

  case is_CFuncDecl:
    free_FuncDecl(p->u.cfuncdecl_.funcdecl_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ClassMemDecl!\n");
    exit(1);
  }
  free(p);
}

void free_ListClassMemDecl(ListClassMemDecl listclassmemdecl)
{
  if (listclassmemdecl)
  {
    free_ClassMemDecl(listclassmemdecl->classmemdecl_);
    free_ListClassMemDecl(listclassmemdecl->listclassmemdecl_);
    free(listclassmemdecl);
  }
}

void free_TypeArg(TypeArg p)
{
  switch(p->kind)
  {
  case is_TSimp:
    free(p->u.tsimp_.iden_);
    break;

  case is_TCov:
    free(p->u.tcov_.iden_);
    free_Type(p->u.tcov_.type_);
    break;

  case is_TContra:
    free(p->u.tcontra_.iden_);
    free_Type(p->u.tcontra_.type_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TypeArg!\n");
    exit(1);
  }
  free(p);
}

void free_ListTypeArg(ListTypeArg listtypearg)
{
  if (listtypearg)
  {
    free_TypeArg(listtypearg->typearg_);
    free_ListTypeArg(listtypearg->listtypearg_);
    free(listtypearg);
  }
}

void free_TArgsDecl(TArgsDecl p)
{
  switch(p->kind)
  {
  case is_TNil:
    break;

  case is_TDecl:
    free_ListTypeArg(p->u.tdecl_.listtypearg_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TArgsDecl!\n");
    exit(1);
  }
  free(p);
}

void free_FuncDecl(FuncDecl p)
{
  switch(p->kind)
  {
  case is_FFunc:
    free_ListPropDecl(p->u.ffunc_.listpropdecl_);
    free(p->u.ffunc_.iden_);
    free_TArgsDecl(p->u.ffunc_.targsdecl_);
    free_ListParaSig(p->u.ffunc_.listparasig_);
    free_Type(p->u.ffunc_.type_);
    free_FuncBody(p->u.ffunc_.funcbody_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FuncDecl!\n");
    exit(1);
  }
  free(p);
}

void free_FuncBody(FuncBody p)
{
  switch(p->kind)
  {
  case is_FAbsBody:
    break;

  case is_FConBody:
    free_StmtBlock(p->u.fconbody_.stmtblock_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FuncBody!\n");
    exit(1);
  }
  free(p);
}

void free_ParaSig(ParaSig p)
{
  switch(p->kind)
  {
  case is_PSig:
    free(p->u.psig_.iden_);
    free_Type(p->u.psig_.type_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ParaSig!\n");
    exit(1);
  }
  free(p);
}

void free_ListParaSig(ListParaSig listparasig)
{
  if (listparasig)
  {
    free_ParaSig(listparasig->parasig_);
    free_ListParaSig(listparasig->listparasig_);
    free(listparasig);
  }
}

void free_ClassDecl(ClassDecl p)
{
  switch(p->kind)
  {
  case is_CClass:
    free_ListPropDecl(p->u.cclass_.listpropdecl_);
    free(p->u.cclass_.iden_);
    free_TArgsDecl(p->u.cclass_.targsdecl_);
    free_Inhrt(p->u.cclass_.inhrt_);
    free_ListClassMemDecl(p->u.cclass_.listclassmemdecl_);
    break;

  case is_CInter:
    free_ListPropDecl(p->u.cinter_.listpropdecl_);
    free_TArgsDecl(p->u.cinter_.targsdecl_);
    free(p->u.cinter_.iden_);
    free_Inhrt(p->u.cinter_.inhrt_);
    free_ListClassMemDecl(p->u.cinter_.listclassmemdecl_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ClassDecl!\n");
    exit(1);
  }
  free(p);
}

void free_Inhrt(Inhrt p)
{
  switch(p->kind)
  {
  case is_INoInherit:
    break;

  case is_IInherit:
    free_ListCType(p->u.iinherit_.listctype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Inhrt!\n");
    exit(1);
  }
  free(p);
}

void free_Prop(Prop p)
{
  switch(p->kind)
  {
  case is_PName:
    free(p->u.pname_.iden_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Prop!\n");
    exit(1);
  }
  free(p);
}

void free_PropDecl(PropDecl p)
{
  switch(p->kind)
  {
  case is_PProp:
    free_ListProp(p->u.pprop_.listprop_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing PropDecl!\n");
    exit(1);
  }
  free(p);
}

void free_ListProp(ListProp listprop)
{
  if (listprop)
  {
    free_Prop(listprop->prop_);
    free_ListProp(listprop->listprop_);
    free(listprop);
  }
}

void free_ListPropDecl(ListPropDecl listpropdecl)
{
  if (listpropdecl)
  {
    free_PropDecl(listpropdecl->propdecl_);
    free_ListPropDecl(listpropdecl->listpropdecl_);
    free(listpropdecl);
  }
}

void free_VarSig(VarSig p)
{
  switch(p->kind)
  {
  case is_VSig:
    free_ListIden(p->u.vsig_.listiden_);
    free_Type(p->u.vsig_.type_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing VarSig!\n");
    exit(1);
  }
  free(p);
}

void free_VarDef(VarDef p)
{
  switch(p->kind)
  {
  case is_VNoAsn:
    free_VarSig(p->u.vnoasn_.varsig_);
    break;

  case is_VAsn:
    free_VarSig(p->u.vasn_.varsig_);
    free_ListExp(p->u.vasn_.listexp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing VarDef!\n");
    exit(1);
  }
  free(p);
}

void free_GVarDef(GVarDef p)
{
  switch(p->kind)
  {
  case is_MPropVar:
    free_ListPropDecl(p->u.mpropvar_.listpropdecl_);
    free_VarDef(p->u.mpropvar_.vardef_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing GVarDef!\n");
    exit(1);
  }
  free(p);
}

void free_CType(CType p)
{
  switch(p->kind)
  {
  case is_CSimp:
    free(p->u.csimp_.iden_);
    break;

  case is_CGen:
    free(p->u.cgen_.iden_);
    free_ListType(p->u.cgen_.listtype_);
    break;

  case is_CList:
    free_Type(p->u.clist_.type_);
    break;

  case is_CTup:
    free_ListType(p->u.ctup_.listtype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CType!\n");
    exit(1);
  }
  free(p);
}

void free_ListCType(ListCType listctype)
{
  if (listctype)
  {
    free_CType(listctype->ctype_);
    free_ListCType(listctype->listctype_);
    free(listctype);
  }
}

void free_Type(Type p)
{
  switch(p->kind)
  {
  case is_TMaybe:
    free_CType(p->u.tmaybe_.ctype_);
    break;

  case is_TPure:
    free_CType(p->u.tpure_.ctype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Type!\n");
    exit(1);
  }
  free(p);
}

void free_ListType(ListType listtype)
{
  if (listtype)
  {
    free_Type(listtype->type_);
    free_ListType(listtype->listtype_);
    free(listtype);
  }
}

void free_Lit(Lit p)
{
  switch(p->kind)
  {
  case is_LInt:
    break;

  case is_LStr:
    free(p->u.lstr_.string_);
    break;

  case is_LChr:
    break;

  case is_LFlo:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Lit!\n");
    exit(1);
  }
  free(p);
}

void free_Op(Op p)
{
  switch(p->kind)
  {
  case is_Asn:
    break;

  case is_AddAsn:
    break;

  case is_SubAsn:
    break;

  case is_MulAsn:
    break;

  case is_DivAsn:
    break;

  case is_ModAsn:
    break;

  case is_AndAsn:
    break;

  case is_XorAsn:
    break;

  case is_OrAsn:
    break;

  case is_ShlAsn:
    break;

  case is_ShrAsn:
    break;

  case is_LogOr:
    break;

  case is_LogAnd:
    break;

  case is_BitOr:
    break;

  case is_BitXor:
    break;

  case is_BitAnd:
    break;

  case is_NotEq:
    break;

  case is_Eq:
    break;

  case is_Lt:
    break;

  case is_Gt:
    break;

  case is_Leq:
    break;

  case is_Geq:
    break;

  case is_Shl:
    break;

  case is_Shr:
    break;

  case is_Add:
    break;

  case is_Sub:
    break;

  case is_Mul:
    break;

  case is_Div:
    break;

  case is_Mod:
    break;

  case is_Pow:
    break;

  case is_Ref:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Op!\n");
    exit(1);
  }
  free(p);
}

void free_Stmt(Stmt p)
{
  switch(p->kind)
  {
  case is_SExp:
    free_Exp(p->u.sexp_.exp_);
    break;

  case is_SDecl:
    free_VarDef(p->u.sdecl_.vardef_);
    break;

  case is_SRetNil:
    break;

  case is_SRet:
    free_Exp(p->u.sret_.exp_);
    break;

  case is_SBreak:
    break;

  case is_SCont:
    break;

  case is_SIf:
    free_AliasIf(p->u.sif_.aliasif_);
    break;

  case is_SFor:
    free(p->u.sfor_.iden_);
    free_Exp(p->u.sfor_.exp_);
    free_StmtBlock(p->u.sfor_.stmtblock_);
    break;

  case is_SWhile:
    free_Exp(p->u.swhile_.exp_);
    free_StmtBlock(p->u.swhile_.stmtblock_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Stmt!\n");
    exit(1);
  }
  free(p);
}

void free_Else(Else p)
{
  switch(p->kind)
  {
  case is_EEmpty:
    break;

  case is_EElse:
    free_StmtBlock(p->u.eelse_.stmtblock_);
    break;

  case is_EElif:
    free_AliasIf(p->u.eelif_.aliasif_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Else!\n");
    exit(1);
  }
  free(p);
}

void free_AliasIf(AliasIf p)
{
  switch(p->kind)
  {
  case is_AIf:
    free_Exp(p->u.aif_.exp_);
    free_StmtBlock(p->u.aif_.stmtblock_);
    free_Else(p->u.aif_.else_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing AliasIf!\n");
    exit(1);
  }
  free(p);
}

void free_ListStmt(ListStmt liststmt)
{
  if (liststmt)
  {
    free_Stmt(liststmt->stmt_);
    free_ListStmt(liststmt->liststmt_);
    free(liststmt);
  }
}

void free_StmtBlock(StmtBlock p)
{
  switch(p->kind)
  {
  case is_SStmt:
    free_ListStmt(p->u.sstmt_.liststmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing StmtBlock!\n");
    exit(1);
  }
  free(p);
}

void free_Exp(Exp p)
{
  switch(p->kind)
  {
  case is_EOp:
    free_Exp(p->u.eop_.exp_1);
    free_Op(p->u.eop_.op_);
    free_Exp(p->u.eop_.exp_2);
    break;

  case is_PreInc:
    free_Exp(p->u.preinc_.exp_);
    break;

  case is_PreDec:
    free_Exp(p->u.predec_.exp_);
    break;

  case is_Pos:
    free_Exp(p->u.pos_.exp_);
    break;

  case is_Neg:
    free_Exp(p->u.neg_.exp_);
    break;

  case is_LogNot:
    free_Exp(p->u.lognot_.exp_);
    break;

  case is_BitNot:
    free_Exp(p->u.bitnot_.exp_);
    break;

  case is_SufInc:
    free_Exp(p->u.sufinc_.exp_);
    break;

  case is_SufDec:
    free_Exp(p->u.sufdec_.exp_);
    break;

  case is_ArrIdx:
    free_Exp(p->u.arridx_.exp_1);
    free_Exp(p->u.arridx_.exp_2);
    break;

  case is_FuncCall:
    free_Exp(p->u.funccall_.exp_);
    free_TArgsPass(p->u.funccall_.targspass_);
    free_ListExp(p->u.funccall_.listexp_);
    break;

  case is_ELit:
    free_Lit(p->u.elit_.lit_);
    break;

  case is_EIde:
    free(p->u.eide_.iden_);
    break;

  case is_ENil:
    break;

  case is_ESing:
    free(p->u.esing_.iden_);
    free_LamBody(p->u.esing_.lambody_);
    break;

  case is_EMore:
    free_ListIden(p->u.emore_.listiden_);
    free_LamBody(p->u.emore_.lambody_);
    break;

  case is_ETupOne:
    free_Exp(p->u.etupone_.exp_);
    break;

  case is_ETupTwo:
    free_Exp(p->u.etuptwo_.exp_1);
    free_Exp(p->u.etuptwo_.exp_2);
    free_OptionExp(p->u.etuptwo_.optionexp_);
    break;

  case is_EList:
    free_ListExp(p->u.elist_.listexp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Exp!\n");
    exit(1);
  }
  free(p);
}

void free_TArgsPass(TArgsPass p)
{
  switch(p->kind)
  {
  case is_TPNil:
    break;

  case is_TPass:
    free_ListType(p->u.tpass_.listtype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TArgsPass!\n");
    exit(1);
  }
  free(p);
}

void free_ListExp(ListExp listexp)
{
  if (listexp)
  {
    free_Exp(listexp->exp_);
    free_ListExp(listexp->listexp_);
    free(listexp);
  }
}

void free_OptionExp(OptionExp p)
{
  switch(p->kind)
  {
  case is_ONil:
    break;

  case is_OExp:
    free_ListExp(p->u.oexp_.listexp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OptionExp!\n");
    exit(1);
  }
  free(p);
}

void free_LamBody(LamBody p)
{
  switch(p->kind)
  {
  case is_LExp:
    free_Exp(p->u.lexp_.exp_);
    break;

  case is_LStm:
    free_StmtBlock(p->u.lstm_.stmtblock_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing LamBody!\n");
    exit(1);
  }
  free(p);
}

